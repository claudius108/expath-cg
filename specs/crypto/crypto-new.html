<!DOCTYPE html>
<html>
	<head>
		<title>Cryptographic Module 1.0</title>
		<meta charset="utf-8" />
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
		<script class="remove">
			var respecConfig = {
			// the CG
			wg: "EXPath Community Group",
			wgURI:
			"https://www.w3.org/community/expath/",
			wgPublicList: "public-expath",
			//github:
			//"https://github.com/expath/expath-cg/",
			//repoURL: "https://github.com/expath/expath-cg/",

			// specification status
			//(e.g. WD, LCWD, NOTE, etc.). CG-DRAFT and CG-FINAL for CG reports
			specStatus: "CG-FINAL",
			shortName: "expath-crypto",

			// once the final report is published
			publishDate: "2018-11-08",

			// if there a publicly available Editor's Draft, this
			//is the link
			edDraftURI: "https://expath.github.io/expath-cg/specs/crypto/",

			// editors, add as many as you like, only
			//"name" is required
			editors: [
			{ name: "Claudius Teodorescu", url: "https://kuberam.ro/" }
			],

			doRDFa: "1.1",

			//references
			//that do not exist on specref
			// localBiblio: {
			// "some-label": {
			// title: "The title",
			// href:
			//"https://example.org/the-stuff",
			// status: "REC",
			// publisher: "Xyz",
			// authors: [
			// "Bla bla",
			// ],
			// versions: [
			//"version-tag-20100109",
			// ]
			// }
			// },

			otherLinks: [{
			key: 'Previous versions',
			data: [{
			value:
			'http://expath.org/spec/crypto/20110810',
			href: 'http://expath.org/spec/crypto/20110810'
			}, {
			value:
			'http://expath.org/spec/crypto/20150214',
			href: 'http://expath.org/spec/crypto/20150214'
			}, {
			value:
			'http://expath.org/spec/crypto/20170320',
			href: 'http://expath.org/spec/crypto/20170320'
			}]
			}, {
			key: 'Participate',
			data: [{
			value: 'GitHub expath/expath-cg',
			href: 'https://github.com/expath/expath-cg/'
			}, {
			value: 'Report an issue',
			href: 'https://github.com/expath/expath-cg/issues/'
			}]
			}],

			};
		</script>
		<style type="text/css">

			pre, code, samp {
			color: black !important;
			font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco,
			monospace;
			font-size: .9em;
			page-break-inside: avoid;
			hyphens: none;
			text-transform: none;
			text-align: left;
			text-align:
			start;
			}

			div.proto, pre.proto {
			color: black;
			border: 0;
			border-spacing: 0;
			padding: .5em;
			border: .5em;
			border-left-style:
			solid;
			page-break-inside: avoid;
			margin: 1em auto;
			border-color: #ff99ff;
			background: #ffe6ff;
			overflow: auto;
			}

			div.proto
			pre {
			padding: 0;
			margin-bottom: 0;
			margin-top: 0;
			}

			code.function {
			font-weight: bold;
			}

			code.return-type, code.type {
			font-style: italic;
			}

			code.return-varies {
			font-weight: bold;
			font-style: italic;
			}

			code.as {
			font-style: normal;
			}

			code.arg {
			}

			div.exampleHeader {
			font-weight: bold;
			margin: 4px;
			}

			div.exampleInner {
			background-color: #d5dee3;
			padding: 4px;
			margin:
			0em;
			}

			div.exampleInner pre {
			margin-left: 1em;
			margin-top: 0em;
			margin-bottom: 0em;
			}

			p>code, li>code {
			font-family:
			Consolas, "Liberation Mono", Menlo, Courier, monospace;
			box-sizing: border-box;
			padding: 0;
			padding-top: 0px;
			padding-bottom: 0px;
			padding-top: 0.2em;
			padding-bottom: 0.2em;
			margin: 0;
			font-size: 85%;
			background-color:
			rgba(0,0,0,0.04);
			border-radius: 3px;
			color: #333;
			}

			table.proto td {
			vertical-align: baseline;
			}

			var {
			font-style: italic;
			}
			
			table.minborder {
				border: 1px solid #000000;
				border-collapse: collapse;
				word-wrap: normal;
				overflow-wrap: normal;
				hyphens: manual;
				font-size: smaller;
			}
			table.minborder tbody {
				display: table-row-group;
			}
			table.minborder th {
				border: 1px solid #000000;
				text-align: center;
			}
			table.minborder td {
			border: 1px solid #000000;
			text-align: start;
			padding-left: 5px;
			}			
			
			#table-1 {
				border: 1px solid black;
				padding: 3px;
			}
			
			#table-1 th {
				text-align: center;
				border: 1px solid black;	
			}
			#table-1 td {
				border: 1px solid black;
				padding: 5px;
			}			
		</style>
	</head>
	<body>
		<section id="abstract">
			<p>
				This specification defines a set of extension to perform cryptographic operations. These functions are related to
				XML Digital Signature, to encryption and decryption, to hashing and digesting of messages, etc.
			</p>
			<p>
				It has been designed to be compatible via [[!XPATH-31]] with [[!XQUERY-31]], and [[!XSLT-30]]. It should also be
				suitable for any other language which hosts XPath 3.1, such as [[!XPROC]].
			</p>
			<p>
				The functions are defined based upon the datatypes defined in [[!xmlschema-2]] and [[!xpath-datamodel-31]]. Also,
				the functions are defined for nodes and node sequences as defined in [[!xpath-datamodel-31]] and are following the
				good practices inferred from [[!xpath-functions-31]].
			</p>
		</section>

	    <section id="sotd">
	    </section>

		<section id="introductory">
			<h2>Introduction</h2>
			<section>
				<h3>Generalities</h3>
				<p>Cryptography is the science of communicating in secret code, by conversion of data with the help of a key. In
					modern times, cryptography is necessary when communicating over any untrusted medium, particularly the Internet.
				</p>
				<p>Encryption of data can be of two types: symmetric and asymmetric. Symmetric encryption means that the same key is
					used for encryption and decryption. Asymmetric encryption means that a message can be encrypted by using a key that
					is public, but the decryption can be made only by using a private key, which form a pair with the respective public
					key.
				</p>
				<p>A related technique of cryptography is to apply a one-way hash or digest function to data; replicating the
					operation with the same data and function can ensure the integrity of the data.
				</p>
			</section>
			<section>
				<h3>Namespace conventions</h3>
				<p>
					The module defined by this document defines one function in the namespace
					<code>http://expath.org/ns/crypto</code>
					. In this document, the
					<code>crypto</code>
					prefix, when used, is bound to this namespace URI.
				</p>
				<p>
					Error codes are defined in the namespace
					<code>http://expath.org/ns/error</code>
					. In this
					document, the
					<code>err</code>
					prefix, when used, is bound to this namespace URI.
				</p>
			</section>
			<section>
				<h3>Error management</h3>
				<p>
					Error conditions are identified by a code (a
					<code>QName</code>
					). When such an error
					condition is reached during the execution of the function, a dynamic error is thrown, with
					the
					corresponding error code (as if the standard XPath function
					<a data-cite="xpath-functions#func-error">fn:error</a>
					had been called).
				</p>
				<p>
					There are many cases when the cryptographic operations may raise an dfn-errCRYPTO In each case, if the error
					condition is
					not mentioned explicitly in the spec, the implementation MUST raise an error with the error code
					<a>err:CRYPTO001</a>
					.
				</p>
			</section>
		</section>
		<section>
			<h2>Qualified Names of the Cryptographic Services</h2>
			<p>This section defines the qualified names of the cryptographic services described by the current specification.</p>
			<p>These QNames are used for listing the providers that provide the needed service, or for listing the algorithms a
				provider use for the needed service. They are defined as variables, for convenient use.</p>
			<table class="minborder">
				<caption>QNames for Cryptographic Services</caption>
				<thead>
					<tr>
						<th>
							Cryptographic Service
							<br />
							QName
						</th>
						<th>XDM Type</th>
						<th>Value</th>
						<th>Cryptographic Service<br />Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>$crypto:hashing</td>
						<td>xs:string</td>
						<td>xs:string</td>
						<td></td>
					</tr>
					<tr>
						<td>crypto:hmac</td>
						<td>xs:string</td>
						<td>xs:string</td>
						<td></td>
					</tr>
					<tr>
						<td></td>
						<td>xs:string</td>
						<td>xs:string</td>
						<td></td>
					</tr>						
				</tbody>
			</table>
		</section>
		<section>
		    <h2>Cryptographic Service Providers</h2>
		    <p>Cryptographic providers provide cryptographic services, involving cryptographic operations (encryption, digital 
			signatures, message digests, message authentication),
		generators and converters of cryptographic material and cryptographic objects (keystores or certificates) containing 
			the cryptographic data. They can be implemented
		using software, hardware, or both.</p>
		    <section>
		        <h3>The 
		            <code>crypto:list-providers</code> function
		        </h3>
		        <p>This function lists the available cryptographic providers.</p>
		        <eg>
		            <spec:function>crypto:list-providers</spec:function>() as 
		            <spec:type>element(crypto:provider-list)</spec:type>
		        </eg>
		        <section>
		            <h4>The 
		                <code>crypto:providers-list</code> element
		            </h4>
		            <p>The 
		                <code>crypto:providers-list</code> element represents the list of the available cryptographic providers:
		            </p>
		            <eg>
		&lt;crypto:providers-list&gt;
		(crypto:provider*)
		&lt;/crypto:providers-list&gt;
		</eg>
		        </section>
		        <section>
		            <h4>The 
		                <code>crypto:provider</code> element
		            </h4>
		            <p>The 
		                <code>crypto:provider</code> element contains the name of an available cryptographic provider:
		            </p>
		            <eg>
		&lt;crypto:provider name = xs:string
		version = xs:string&gt;
		&lt;/crypto:provider&gt;
		</eg>
		        </section>
		    </section>
		    <section>
		        <head>The 
		            <code>crypto:list-services</code> function
		        </head>
		        <p>This function lists the cryptographic services a provider provides.</p>
		        <eg>
		            <spec:function>crypto:list-services</spec:function>($provider-name as 
		            <spec:type>xs:string</spec:type>) as 
		            <spec:type>element(crypto:service-list)</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$provider-name</code> is the provider's name. TBD: case when provider is not registered, etc.
		                </p>
		            </item>
		        </ulist>
		        <section>
		            <h4>The 
		                <code>crypto:services-list</code> element
		            </h4>
		            <p>The 
		                <code>crypto:services-list</code> element represents the list of the available cryptographic services for a 
			provider:
		            </p>
		            <eg>
		&lt;crypto:services-list&gt;
		(crypto:service*)
		&lt;/crypto:services-list&gt;
		</eg>
		        </section>
		        <section>
		            <h4>The 
		                <code>crypto:service</code> element
		            </h4>
		            <p>The 
		                <code>crypto:service</code> element contains details about an available cryptographic service:
		            </p>
		            <eg>
		&lt;crypto:service qname = xsd:QName
		algorithm? = xs:string
		type? = xs:string
		format? = xs:string?/&gt;
		</eg>
		        </section>
		    </section>
		</section>
		<section>
			<h2>Cryptographic Key Management</h2>
			<p>TBD.</p>
			<section>
				<h3>
					The
					<code>crypto:generate-key-pair</code>
					function
				</h3>
				<p>This function generates a new pair of public and private cryptographic keys, to be used with a specific
					cryptographic
					algorithm.</p>
			</section>
			<section>
				<h3>
					The
					<code>crypto:generate-secret-key</code>
					function
				</h3>
				<p>This function generates a new secret key, to be used with a specific cryptographic algorithm.</p>
			</section>
			<section>
				<h3>
					The
					<code>crypto:compare-keys</code>
					function
				</h3>
				<p></p>
			</section>
			<section>
				<h3>
					The
					<code>crypto:key-agrement</code>
					function
				</h3>
				<p>http://ietf.org/rfc/rfc2631.txt,
					http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#KeyAgreement</p>
			</section>
			<section>
				<h3>
					The
					<code>crypto:convert-key-specification-to-key-object, crypto:convert-key-object-to-key-specification</code>
					function
				</h3>
				<p>http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#KeyFactory,
					http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#SecretKeyFactory (for secret
					(symmetric) keys)
				</p>
			</section>
		</section>
		<section>
			<h2>Integrity and Authentication of Data</h2>
			<section>
				<h3>
					<dfn>crypto:hash</dfn>
				</h3>
				<dl>
					<dt class="label">Summary</dt>
					<dd>
						<p>This function generates a "message digest" of the input data, by using a cryptographic algorithm.</p>
					</dd>
					<dt class="label">Signatures</dt>
					<dd>
						<div class="proto">
							<table class="proto">
								<tbody>
									<tr>
										<td rowspan="3">
											<code class="function">crypto:hash</code>
											(
										</td>
										<td>
											<code class="arg">$data</code>
										</td>
										<td>
											<code class="as"> as </code>
											<code class="type">xs:anyAtomicType?</code>
											,
										</td>
									</tr>
									<tr>
										<td>
											<code class="arg">$algorithm </code>
										</td>
										<td>
											<code class="as"> as </code>
											<code class="type">xs:string</code>
											)
											<code class="as"> as </code>
											<code class="return-type">xs:string</code>
										</td>
									</tr>
								</tbody>
							</table>
						</div>
						<div class="proto">
							<table class="proto">
								<tbody>
									<tr>
										<td rowspan="3">
											<code class="function">crypto:hash</code>
											(
										</td>
										<td>
											<code class="arg">$data</code>
										</td>
										<td>
											<code class="as"> as </code>
											<code class="type">xs:anyAtomicType?</code>
											,
										</td>
									</tr>
									<tr>
										<td>
											<code class="arg">$algorithm </code>
										</td>
										<td>
											<code class="as"> as </code>
											<code class="type">xs:string</code>
											,
										</td>
									</tr>
									<tr>
										<td>
											<code class="arg">encoding </code>
										</td>
										<td>
											<code class="as"> as </code>
											<code class="type">xs:string</code>
											)
											<code class="as"> as </code>
											<code class="return-type">xs:string</code>
										</td>
									</tr>
								</tbody>
							</table>
						</div>
					</dd>
					<dt class="label">Properties</dt>
					<dd>
						<p>
							This function is
							<a title="deterministic" class="termref" data-cite="xpath-functions#dt-deterministic">
								<span class="arrow">·</span>
								deterministic
								<span class="arrow">·</span>
							</a>
							,
							<a title="context-independent" class="termref" data-cite="xpath-functions#dt-context-independent">
								<span class="arrow">·</span>
								context-independent
								<span class="arrow">·</span>
							</a>
							, and
							<a title="focus-independent" class="termref" data-cite="xpath-functions#dt-focus-independent">
								<span class="arrow">·</span>
								focus-independent
								<span class="arrow">·</span>
							</a>
							.
						</p>
					</dd>
					<dt class="label">Rules</dt>
					<dd>
						<p>
							The function
							<code>map:keys</code>
							takes any
							<a title="map" class="termref" href="#dt-map">
								<span class="arrow">·</span>
								map
								<span class="arrow">·</span>
							</a>
							as its
							<code>$map</code>
							argument and returns the keys that are present in the map as
							a sequence of atomic values, in
							<a title="" class="termref" href="#">
								<span class="arrow">·</span>
								implementation-dependent
								<span class="arrow">·</span>
							</a>
							order.
						</p>
						<p>
							The function is
							<b>non-deterministic with respect to ordering</b>
							(see
							<a href="#properties-of-functions">
								<b>1.7.4 Properties of functions</b>
							</a>
							). This means that two calls with the same argument
							are not guaranteed to produce the results in the same order.
						</p>
					</dd>
					<dt class="label">Notes</dt>
					<dd>
						<p class="note">The number of items in the result will be the same as the number of
							entries in the map, and the result sequence will contain no duplicate values.
						</p>
					</dd>
					<dt class="label">Examples</dt>
					<dd>
						<div class="example">
							<p>
								The expression
								<code>map:keys(map{1:"yes", 2:"no"})</code>
								returns some permutation of
								<code>(1,2)</code>
								.
								<em>
									(The result is in
									<a title="" class="termref" href="#">
										<span class="arrow">·</span>
										implementation-dependent
										<span class="arrow">·</span>
									</a>
									order.)
								</em>
							</p>
						</div>
					</dd>
				</dl>








				<ul>
					<li>
						<code>$data</code>
						is the data to be hashed. This parameter can be of type
						<code>xs:string</code>
						,
						<code>xs:base64Binary</code>
						, or
						<code>xs:hexBinary</code>
						.
					</li>
					<li>
						<code>$algorithm</code>
						is the cryptographic hashing algorithm. If it is specified an unsupported algorithm, it MUST throw the error
						<a>err:CRYPTO002</a>
						. The supported algorithms are implementation dependent.
					</li>
					<li>
						<code>$encoding</code>
						is the encoding of the output. The legal values are
						<code>hex</code>
						and
						<code>base64</code>
						. The default value is
						<code>base64</code>
						.
					</li>
				</ul>
			</section>
			<section>
				<h3>
					<dfn>crypto:hmac</dfn>
				</h3>
				<p>
					<a data-cite="rfc2104">HMAC (Keyed-Hashing for Message Authentication)</a>
					is a mechanism for message authentication using cryptographic hash functions. HMAC can be used with any iterative
					cryptographic hash function in combination with a secret shared key. Typically, message authentication codes are
					used between two parties that share a secret key in order to validate information transmitted between these
					parties.
				</p>
				<p>
					This function generates a message authentication code, based on the input message, by using a cryptographic
					algorithm and a secret key. It has two
					signatures; the first one outputs the result as
					<code>xs:byte*</code>
					, while the second one outputs the result as
					encoded
					<code>xs:string</code>
					. The first signature can be used for successive calls of this function, as can be seen in the <a href="#generation-of-aws-signature-version-4" class="sectionRef">example</a> below.
				</p>
				<div class="proto">
					<table class="proto">
						<tbody>
							<tr>
								<td rowspan="3">
									<code class="function">crypto:hmac</code>
									(
								</td>
								<td>
									<code class="arg">$data</code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:anyAtomicType?</code>
									,
								</td>
							</tr>
							<tr>
								<td>
									<code class="arg">$key </code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:anyAtomicType</code>
									,
								</td>
							</tr>
							<tr>
								<td>
									<code class="arg">$algorithm </code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:string</code>
									)
									<code class="as"> as </code>
									<code class="return-type">xs:byte*</code>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<div class="proto">
					<table class="proto">
						<tbody>
							<tr>
								<td rowspan="4">
									<code class="function">crypto:hmac</code>
									(
								</td>
								<td>
									<code class="arg">$data</code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:anyAtomicType?</code>
									,
								</td>
							</tr>
							<tr>
								<td>
									<code class="arg">$key </code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:anyAtomicType</code>
									,
								</td>
							</tr>
							<tr>
								<td>
									<code class="arg">$algorithm </code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:string</code>
									,
								</td>
							</tr>
							<tr>
								<td>
									<code class="arg">$encoding </code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">xs:string</code>
									)
									<code class="as"> as </code>
									<code class="return-type">xs:string</code>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
				<ul>
					<li>
						<code>$data</code>
						is the data to be authenticated. This parameter can be of type
						<code class="type">xs:string</code>
						,
						<code class="type">xs:byte*</code>
						,
						<code class="type">xs:base64Binary</code>
						, or
						<code class="type">xs:hexBinary</code>
						.
					</li>
					<li>
						<code>$key</code>
						is the secret key used for calculating the authentication code. This parameter can be of type
						<code class="type">xs:string</code>
						,
						<code class="type">xs:byte*</code>
						,
						<code class="type">xs:base64Binary</code>
						, or
						<code class="type">xs:hexBinary</code>
						.
					</li>

					<li>
						<code>$algorithm</code>
						is the cryptographic hashing algorithm. If it is specified an unsupported algorithm, it MUST throw the error
						<a>err:CRYPTO002</a>
						. The supported algorithms are implementation dependent.
					</li>
					<li>
						<code>$encoding</code>
						is the encoding of the output. The legal values are
						<code class="type">hex</code>
						and
						<code class="type">base64</code>
						. The result is generated accordingly, as
						<code class="type">xs:base64Binary</code>
						string or
						<code class="type">xs:hexBinary string</code>
						.
					</li>
				</ul>
			</section>
		</section>

		<section>
			<h2>XML Digital Signature</h2>
			<p>A digital signature is a technique to certify that a digital document (including XML) is authentic. This means that
				the origin of the document is known and there is the ability to identify if the digital document has been changed
				since the digital signature was applied to it. This is done by means of a cryptographic transformation, which is any
				pre-processing of the input data before signing.</p>
			<p>
				This function can apply an XML digital signature to one or more digital resources. According to [[!xmldsig-core1]],
				there are three types of XML digital signatures, namely
				<a data-cite="xmldsig-core1#def-SignatureEnveloped">enveloped</a>
				,
				<a data-cite="xmldsig-core1#def-SignatureEnveloping">enveloping</a>
				, and
				<a data-cite="xmldsig-core1#def-SignatureDetached">detached</a>
				signatures.
			</p>
			<section>
				<h3>
					The
					<dfn>crypto:generate-signature</dfn>
					function
				</h3>
				<p>
					This function is used to generate an XML Digital Signature. After the function's signature, an example of parameters is given.
				</p>
				<div class="proto">
					<table class="proto">
						<tbody>
							<tr>
								<td rowspan="2">
									<code class="function">crypto:generate-signature</code>
									(
								</td>
								<td>
									<code class="arg">$data</code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">item()*</code>
									,
								</td>
							</tr>
							<tr>
								<td>
									<code class="arg">$parameters </code>
								</td>
								<td>
									<code class="as"> as </code>
									<code class="type">map(xs:string, item()+)</code>
									)
									<code class="as"> as </code>
									<code class="return-type">item()*</code>
								</td>
							</tr>
						</tbody>
					</table>
				</div>				
				<ul>
					<li>
						<p>
							<code>$data</code>
							is the data to be signed.
						</p>
					</li>
					<li>
						<p>
							<code>$parameters</code>
							represent the parameters used for generating the XML digital signature. For details regarding these parameters,
							see the
							<a href="#example-of-parameters-parameter" class="sectionRef">example</a>
							below, and the two tables following, which 							
							<a href="#explanations-about-parameters-parameter" class="sectionRef">table</a>
							below 
							and the
.
						</p>
					</li>
				</ul>
				<section id="explanations-about-parameters-parameter">
					<h4>
						Explanations about
						<code>$parameters</code>
						parameter
					</h4>				
					<table id="table-1">
						<caption>Parameters used for generating a XML digital signature</caption>
						<thead>
							<tr>
								<th>
									Key<br/>(as
									<code>xs:string</code>)
								</th>
								<th>Value</th>
								<th>Meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<code>canonicalization-algorithm</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>
									<p>The canonicalization algorithm applied to the
									<code>SignedInfo</code>
									element prior to performing signature calculations. Possible values are given in the list
									below. The default value is "inclusive-with-comments-1.1". If the parameter specifies an unsupported algorithm, it MUST throw the error
									<a>err:CRYPTO002</a>
									. (This parameter is optional)
									</p>
									<p>List of values:</p>
									<ul>
										<li>
											<p>
												<code>inclusive-1.1</code>
												, identifier
												<code>http://www.w3.org/2006/12/xml-c14n11</code>
												, for XML 1.1 documents, see
												<bibref ref="xml-dig-sig-core" />
												, section 6.5.2 Canonical XML 1.1.
											</p>
										</li>
										<li>
											<p>
												<code>inclusive-with-comments-1.1</code>
												, identifier
												<code>http://www.w3.org/2006/12/xml-c14n11#WithComments</code>
												, for XML 1.1 documents, see
												<bibref ref="xml-dig-sig-core" />
												, section 6.5.2 Canonical XML 1.1.
											</p>
										</li>
										<li>
											<p>
												<code>inclusive-1.0</code>
												, identifier
												<code>http://www.w3.org/TR/2001/REC-xml-c14n-20010315</code>
												, for XML 1.0 documents, see
												<bibref ref="xml-dig-sig-core" />
												, section 6.5.1 Canonical XML 1.0.
											</p>
										</li>
										<li>
											<p>
												<code>inclusive-with-comments-1.0</code>
												, identifier
												<code>http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments</code>
												, for XML 1.0 documents, see
												<bibref ref="xml-dig-sig-core" />
												, section 6.5.1 Canonical XML 1.0.
											</p>
										</li>
										<li>
											<p>
												<code>exclusive</code>
												, identifier
												<code>http://www.w3.org/2001/10/xml-exc-c14n#</code>
												, see
												<bibref ref="xml-exc-c14n" />
												, section 4. Use in XML Security.
											</p>
										</li>
										<li>
											<p>
												<code>exclusive-with-comments</code>
												, identifier
												<code>http://www.w3.org/2001/10/xml-exc-c14n#WithComments</code>
												, see
												<bibref ref="xml-exc-c14n" />
												, section 4. Use in XML Security.
											</p>
										</li>
									</ul>
								</td>
							</tr>
							<tr>
								<td>
									<code>digest-algorithm</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>
									The digest algorithm to be applied to the signed object. Possible values are: "SHA1" (identifier
									<code>http://www.w3.org/2000/09/xmldsig#sha1</code>
									, see
									<bibref ref="xml-dig-sig-core" />
									, section 6.1 Algorithm Identifiers and Implementation Requirements), "SHA256", and "SHA512". The default value
									is "SHA1". If the parameter specifies an
									unsupported algorithm, this is an error
									<bibref ref="error.unknownAlgorithm" />
									. (Optional)
								</td>
							</tr>
							<tr>
								<td>
									<code>signature-algorithm</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>
									The algorithm used for signature generation and validation. Possible values are: "DSAwithSHA1" (identifier
									<code>http://www.w3.org/2000/09/xmldsig#dsa-sha1</code>
									,
									see
									<bibref ref="xml-dig-sig-core" />
									, section 6.1 Algorithm Identifiers and Implementation Requirements), and "RSAwithSHA1" (identifier
									<code>http://www.w3.org/2000/09/xmldsig#rsa-sha1</code>
									,
									see
									<bibref ref="xml-dig-sig-core" />
									, section 6.1 Algorithm Identifiers and Implementation Requirements). The default value is "DSAwithSHA1". If
									the parameter specifies an unsupported algorithm,
									this is an error
									<bibref ref="error.unknownAlgorithm" />
									. (Optional)
								</td>
							</tr>
							<tr>
								<td>
									<code>signature-namespace-prefix</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>The namespace prefix for signature. If this parameter is not provided, the default value of 'dsig' will be
									used. (Optional)</td>
							</tr>
							<tr>
								<td>
									<code>signature-type</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>
									The method used for signing the content of signature. Possible values are: "enveloping", "enveloped", and
									"detached". The default value is "enveloped".
									If the parameter specifies an unsupported signature type, this is an error
									<bibref ref="error.signatureType" />
									. (Optional)
								</td>
							</tr>
							<tr>
								<td>
									<code>references</code>
								</td>
								<td>
									<code>element(Reference)*</code>
								</td>
								<td>
									The references to the digital resources to be signed. If this parameter is not provided, the whole input
									document will be signed. If the signature is of
									<code>enveloped</code>
									or
									<code>enveloping</code>
									type, and more than one resource is inputted to be signed, this is an error
									<bibref ref="error.inputResources" />
									.
									More details about this parameter can be found at
									<specref ref="explanations-about-resources-parameter" />
									. (Optional)
								</td>
							</tr>
							<tr>
								<td>
									<code>key</code>
								</td>
								<td>
									<code>xs:anyAtomicType</code>
								</td>
								<td>
									The secret key used for signing. This parameter can be of type
									<code>xs:string</code>
									,
									<code>xs:base64Binary</code>
									,
									or
									<code>xs:hexBinary</code>
									. If the key is invalid or missing, this is an error
									<bibref ref="error.cryptoKey" />
									.
								</td>
							</tr>
						</tbody>
					</table>
				</section>
				<section id="example-of-parameters-parameter">
					<h4>
						Example of
						<code>$parameters</code>
						parameter
					</h4>
					<pre class="xquery">
map {
	"canonicalization-algorithm" := "inclusive-with-comments",
 	"digest-algorithm" := "SHA1",
 	"signature-algorithm" := "RSA_SHA1",
 	"signature-namespace-prefix" := "digsig",
 	"signature-type" := "enveloped",
 	"references" :=
 		( 
			&lt;Reference xmlns="http://www.w3.org/2000/09/xmldsig#" URI=""&gt;
				&lt;Transforms&gt;
					&lt;Transform Algorithm="http://www.w3.org/2002/06/xmldsig-filter2"&gt;
						&lt;XPath Filter="intersect"&gt;//ToBeSigned&lt;/XPath&gt;
						&lt;XPath Filter="subtract"&gt;//NotToBeSigned&lt;/XPath&gt;
						&lt;XPath Filter="union"&gt;//ReallyToBeSigned&lt;/XPath&gt;
					&lt;/Transform&gt;
				&lt;/Transforms&gt;
			&lt;/Reference&gt;,
			&lt;Reference xmlns="http://www.w3.org/2000/09/xmldsig#" URI="#id"&gt;
				&lt;Transforms&gt;
					&lt;Transform Algorithm="http://www.w3.org/TR/2001/10/xml-exc-c14n" /&gt;
				&lt;/Transforms&gt;
			&lt;/Reference&gt;
		)
	"key" :=
		    "-----BEGIN RSA PRIVATE KEY-----
		MIIEowIBAAKCAQEAhPxBGln4YOcOGOxmRYEN8nzYHYvQx+PP8GnbJ+kW4f6HvH8WMAUa2lTB6gib
		LzJGezhqkMy8NT8ogVz8xbra3AyK/IBDzXpWtPhSxVOCo6hJfTjj7wX3E2AVN9CTUOYrS/3iSu1q
		/6MoB6MDIj8wV0HO1ujXqEip45UgVl+xRVtU+1wiJQ7Gc8GEEyHVtK/X4joiyCEebJhFsI42Z9e4
		aETI/XOaLszyEQeipMRlyznpRL2x0chz+yj7KuwiMqBZmPYyeWBsbldW8xREwnHEyko5GWc6wkEi
		vgFwzKaZWo2ct3pmZ9vwXKecAxbeJbyJQl/PDfSnqcwyhL6pOaSAuQIDAQABAoIBAHo5hnR7wIb/
		lbteetjitjjqeY8eU/OD9DfYcu6Jkth/Ia4jd/cGmhmU0O0Sn96O7KyPu5H+OfUOaWIMXt400LZy
		aMON98NA77RAj4KBMI7OO0z2Hrgu2Vlbc+TqtJskESM04ulOsIroIAB02Ip/XSS1fS+UrbEjp9Fd
		3GzGYp2E6IF/YtTXMiqgdrZVAoDPtxiMR/1KXuETiBkeMxPvXfgePXLi/rYBDcecmfsCEzDX8RZV
		xLoPKFxuLaIrzdVhGVHwp88fB57OufLytmuvro71FNrFzcIO88NyDpEQVnsBadm9Ir0mb5uhYq9j
		YV444b2Gra0/onJm7e/zRUSSJGkCgYEA67Q8gBSADrkc0UCypjnFV8WWCQJBPspb9Vnf2MJi5aYM
		U5Sa/2H+tNoY+fJoa/eDSu1jeAn71TDcXZizihj3IT8gVdoXSncbcTulxEnaOi85Q2uKfSia16rX
		d+MufjJ4UDC7vR/Ve+zIQOxpzBmcFO5cMnLS3mJdpWSdS7DyQpMCgYEAkG+6udsQ02GEKaJZl2mi
		XBqe4Rh187sDCwiqSO5ItS4jUg1xF1cn1PuF2nvjztZyEsaKKYdiqekEQv3jA6gRsWFvRi/abFN3
		zau/5M42v7H1cgU7m+FsDywhN5IRAmGfEyL/2wpKuZ6lD2qqhGkXmxqyEqgmEClyIwxJKHWiAwMC
		gYBCJK8Bpj8VYp8SnZxEh1u4uMrUtlxG2ZSasmDdvBbyqPk2jzI7zm0ipT1zDrJ88dVXNmy+Z9bS
		ycZdQZfIfh8DpmpVjUER9YCu8vUeszbZMx1XrRsM6lMhiGC01PzcDx+yKSrV9NP81cKQbYd27gzd
		1tHqmkxQebwbyLNXZU1mnwKBgDpuiPsBbdgmHkJ9pIMFwCJEvrvPmoBEyuFe2wzwIUfy52UdfP/1
		SW73ZlpSPoIB7Vo9Kc3NMJQOaaP0dC+Zgbbh9RNO7q1eQxxYfCRDbJC2nNZI2amhU4b70mBZ3jm5
		ZpJmWV2y1zIqxRnsjBlPLraX4Sx9DBEDw2H8aWhN1oIjAoGBANc0gizRHGfOK2UASXskuO5Ueias
		6z0V7J/m93E7wK8IQHcZXGloy8S9QSX6uAqe48ZDVCZGPxqq7TppT+P9WsdqkXqxR7M/KLa+7Y6C
		s1tkDtD9uOJN6CsLuVjfuo4ZT5SwC7pq842aQrqJveKWKdzEorQjWKeN8OM2wzEMs0P1
		-----END RSA PRIVATE KEY-----"	
}
	</pre>
				</section>
				<section id="explanations-about-resources-parameter">
					<h4>
						Explanations about
						<code>$resources</code>
						parameter
					</h4>
					<table border="1" frame="border">
						<caption>
							The
							<code>$resources</code>
							parameter
						</caption>
						<thead>
							<tr>
								<th>
									Key (as
									<code>xs:string</code>
									)
								</th>
								<th>Value</th>
								<th>Meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<code>Reference</code>
								</td>
								<td>
									<code>element()</code>
								</td>
								<td>
									This is the parent element for a reference to a resource to be signed. Its namespace is
									<code>http://www.w3.org/2000/09/xmldsig#</code>
									. Its
									<code>URI</code>
									attribute identifies a resource using a URI-Reference (for details see
									<bibref ref="xml-dig-sig-core" />
									, section 4.3.3.1 The URI Attribute).
								</td>
							</tr>
							<tr>
								<td>
									<code>Transforms</code>
								</td>
								<td>
									<code>element()</code>
								</td>
								<td>
									This element contains an ordered list of
									<code>Transform</code>
									elements.
								</td>
							</tr>
							<tr>
								<td>
									<code>Transform</code>
								</td>
								<td>
									<code>element()</code>
								</td>
								<td>
									This element describes how the signer obtained the data object that is to be digested. The
									<code>Algorithm</code>
									attribute's value specifies the name of the
									algorithm to be applied, and the
									<code>Transform</code>
									element's text content provides additional data for processing using that algorithm. For more details and
									schema of this element, see
									<bibref ref="xml-dig-sig-core" />
									, section 4.3.3.4 The Transforms Element.
								</td>
							</tr>
							<tr>
								<td>
									<code>XPath</code>
								</td>
								<td>
									<code>element()</code>
								</td>
								<td>
									The XPath expression to be applied to the input document, in order to get the resource to be signed. The
									version of XPath to be used is 1.0,
									plus a function named
									<code>here</code>
									. The
									<code>Filter</code>
									attribute's value provides the name of the operation (intersection, subtraction and union)
									used for combining the XPath-selected subtrees. For more details, see
									<bibref ref="xml-dig-sig-core" />
									, section 6.6.3 XPath Filtering, and
									<bibref ref="xml-dig-sig-xpath-filer20" />
									.
								</td>
							</tr>
						</tbody>
					</table>
				</section>
			</section>
			<section>
				<h3>
					The
					<code>crypto:validate-signature</code>
					function
				</h3>
				<p>This function validates an XML Digital Signature.</p>
				<eg>
					<spec:function>crypto:validate-signature</spec:function>
					($data as
					<spec:type>document()</spec:type>
					) as
					<spec:type>xs:boolean</spec:type>
				</eg>
				<ulist>
					<item>
						<p>
							<code>$data</code>
							is the enveloped, enveloping, or detached signature. If
							the Signature element cannot be found, this is an error
							<bibref ref="error.sigElem" />
							.
						</p>
					</item>
				</ulist>
			</section>			
		</section>

		<section>
			<h2>Encryption and Decryption</h2>
			<p>Encryption represents the process of conversion of data, by using a secret key (a cipher), in a form (called
				cipher text) that cannot be understood by unautorized
				persons.</p>
			<p>The decryption represents the reverse process, of converting encrypted data back to plain text (original text).</p>
			<p>There are two main types of encryption: symmetric encryption, when both parties, the sender and the receiver, use
				the same secret key, previously exchanged,
				and asymmetric encryption, when a key pair, consisting of a private key and a private key, is used, of which the public
				key is used by sender to encrypt a message that
				can only be decrypted by the receiver, who holds the private key of that key pair.</p>
			<section>
				<h3>
					The
					<code>crypto:encrypt</code>
					function
				</h3>
				<p>This function encrypts data.</p>
				<eg>
					<spec:function>crypto:encrypt</spec:function>
					($data as
					<spec:type>xs:anyAtomicType</spec:type>
					,
					$type as
					<spec:type>xs:string</spec:type>
					,
					$parameters as
					<spec:type>map(xs:string, item())?</spec:type>
					) as
					<spec:type>xs:base64Binary</spec:type>
				</eg>
				<ulist>
					<item>
						<p>
							<code>$data</code>
							is the data to be encrypted. This parameter can be of type xs:string, xs:base64Binary, or xs:hexBinary. When a
							particular padding mechanism
							is requested to be used for the input data, but this mechanism is not made available by the implementation, this is
							an error
							<bibref ref="error.noPadding" />
							.
							Also, when the input data is expected to have a particular padding mechanism, but the data is not padded accordingly
							to this mechanism, this is an error
							<bibref ref="error.incorrectPadding" />
							.
						</p>
					</item>
					<item>
						<p>
							<code>$type</code>
							is the type of encryption. Legal values: "symmetric", and "asymmetric". If the parameter has an illegal value,
							this is an error
							<bibref ref="error.encType" />
							.
						</p>
					</item>
					<item>
						<p>
							<code>$parameters</code>
							represents the parameters needed for the current operation. More details about this parameter can be found at
							<specref ref="explanations-about-parameters-parameter-of-crypto:encrypt" />
							.
						</p>
					</item>
				</ulist>
				<section id="explanations-about-parameters-parameter-of-crypto:encrypt">
				    <h3>Explanations about
				        <code>$parameters</code>
						parameter
									
				    </h3>
				    <table border="1" frame="border">
				        <caption>The
				            <code>$parameters</code>
							parameter of
				            <code>crypto:encrypt</code>
				        </caption>
				        <thead>
				            <tr>
				                <th>Key (as
				                    <code>xs:string</code>
				                </th>
				                <th>Value</th>
				                <th>Meaning</th>
				            </tr>
				        </thead>
				        <tbody>
				            <tr>
				                <td>
				                    <code>key</code>
				                </td>
				                <td>
				                    <code>xs:anyAtomicType</code>
				                </td>
								<td>
									This is the cryptographic key used for encryption. This parameter can be of type xs:string, xs:base64Binary, or
									xs:hexBinary. If the key is invalid or missing, this is an error
									<bibref ref="error.cryptoKey" />
									. If the length of data provided to the block cipher is incorrect, this is an error
									<bibref ref="error.blockSize" />
								</td>
				            </tr>
				            <tr>
				                <td>
				                    <code>algorithm</code>
				                </td>
				                <td>
				                    <code>xs:string</code>
				                </td>
								<td>
									This is the cryptographic algorithm used for encryption. For symmetric encryption, a transformation name can be
									used.
									If the parameter specifies an unsupported algorithm or transformation name or the parameter is missing, this is
									an
									error
									<bibref ref="error.unknownAlgorithm" />
									.
									The supported algorithms are implementation dependent.
								</td>
				            </tr>
				            <tr>
				                <td>
				                    <code>iv</code>
				                </td>
				                <td>
				                    <code>xs:string</code>
				                </td>
								<td>
									This is the initialization vector for symmetric encryption. If the initialization vector is missing or it is
									not as it is requested by the
									encryption algorithm, this is an error
							
									<bibref ref="error.incorrectIV" />
									. For asymmetric encryption, this parameter is not needed.
							
								</td>
				            </tr>
				            <item>
								<p>
									<code>provider</code>
									as
									<spec:type>xs:string</spec:type>
									is the cryptographic provider for the current operation.
									If the provider is not specified, the implementation will use the
									default provider. If the provider does not exist, this is an error
									<bibref ref="error.noProvider" />
									.
								</p>
				            </item>
				        </tbody>
				    </table>
				</section>
			</section>
			<section>
				<h3>
					The
					<code>crypto:decrypt</code>
					function
				</h3>
				<p>This function decrypts data.</p>
				<eg>
					<spec:function>crypto:decrypt</spec:function>
					($data as
					<spec:type>xs:anyAtomicType</spec:type>
					,
					$type as
					<spec:type>xs:string</spec:type>
					,
					$parameters as
					<spec:type>map(xs:string, item())?</spec:type>
					) as
					<spec:type>xs:string</spec:type>
				</eg>
				<ulist>
					<item>
						<p>
							<code>$data</code>
							is the data to be encrypted. This parameter can be of type xs:string, xs:base64Binary, or xs:hexBinary. When a
							particular padding mechanism
							is requested to be used for the input data, but this mechanism is not made available by the implementation, this is
							an error
							<bibref ref="error.noPadding" />
							.
							Also, when the input data is expected to have a particular padding mechanism, but the data is not padded accordingly
							to this mechanism, this is an error
							<bibref ref="error.incorrectPadding" />
							.
						</p>
					</item>
					<item>
						<p>
							<code>$type</code>
							is the type of decryption. Legal values: "symmetric", and "asymmetric". If the parameter has an illegal value,
							this is an error
							<bibref ref="error.decryptionType" />
							.
						</p>
					</item>
					<item>
						<p>
							<code>$parameters</code>
							represents the parameters needed for the current operation. More details about this parameter can be found at
							<specref ref="explanations-about-parameters-parameter-of-crypto:decrypt" />
							.
						</p>
					</item>
				</ulist>
				<section id="explanations-about-parameters-parameter-of-crypto:decrypt">
					<h4>
						Explanations about
						<code>$parameters</code>
						parameter
					</h4>
					<table border="1" frame="border">
						<caption>
							The
							<code>$parameters</code>
							parameter of
							<code>crypto:decrypt</code>
						</caption>
						<thead>
							<tr>
								<th>
									Key (as
									<code>xs:string</code>
									)
								</th>
								<th>Value</th>
								<th>Meaning</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>
									<code>key</code>
								</td>
								<td>
									<code>xs:anyAtomicType</code>
								</td>
								<td>
									This is the cryptographic key used for decryption. This parameter can be of type xs:string, xs:base64Binary, or
									xs:hexBinary. If the key is invalid or missing,
									this is an error
									<bibref ref="error.cryptoKey" />
									. If the length of data provided to the block cipher is incorrect, this is an error
									<bibref ref="error.blockSize" />
									.
								</td>
							</tr>
							<tr>
								<td>
									<code>algorithm</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>
									This is the cryptographic algorithm used for decryption. For symmetric decryption, a transformation name can be
									used.
									If the parameter specifies an unsupported algorithm or transformation name or the parameter is missing, this is
									an error
									<bibref ref="error.unknownAlgorithm" />
									.
									The supported algorithms are implementation dependent.
								</td>
							</tr>
							<tr>
								<td>
									<code>iv</code>
								</td>
								<td>
									<code>xs:string</code>
								</td>
								<td>
									This is the initialization vector for symmetric decryption. If the initialization vector is missing or it is
									not as it is requested by the
									decryption algorithm, this is an error
									<bibref ref="error.incorrectIV" />
									. For asymmetric decryption, this parameter is not needed.
								</td>
							</tr>
							<item>
							<p><code>provider</code> as <spec:type>xs:string</spec:type> is the cryptographic provider for the current operation. 
								If the provider is not specified, the implementation will use the
							default provider. If the provider does not exist, this is an error <bibref ref="error.noProvider"/>.</p>
							</item>
						</tbody>
					</table>
				</section>
			</section>
		</section>
		
		<section>
		    <h2>Secure Storing of Sensitive Keying and Data Material</h2>
		    <p>A secure storage is a collection of CRLs, cryptographic keys, cryptographic certificates, cryptographic certificate 
					chains,
				various secrets, and extensions. It may have different implementation, according to different cryptographic providers.
				Every entry has a unique alias name and can be protected by its own password.</p>
		    <section>
		        <h3>The 
		            <code>crypto:create-secure-store</code> function
		        </h3>
		        <p>This function creates a secure store. It returns the store as xs:base64binary if successfully completed, empty 
					sequence if not.</p>
		        <eg>
		            <spec:function>crypto:create-secure-store</spec:function>($store-format as 
		            <spec:type>xs:string</spec:type>,
				$store-password as 
		            <spec:type>xs:string</spec:type>) as 
		            <spec:type>xs:base64binary</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$store-format</code> is the format of the secure store.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$store-password</code> is the password for the secure store.
		                </p>
		            </item>
		        </ulist>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:load-secure-store</code> function
		        </h3>
		        <p>This function loads a secure store in order to operate against it. It returns an xs:long representing the secure 
					store handle.</p>
		        <eg>
		            <spec:function>crypto:load-secure-store</spec:function>($secure-store as 
		            <spec:type>xs:base64binary</spec:type>,
				$store-password as 
		            <spec:type>xs:string</spec:type>) as 
		            <spec:type>xs:long</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$secure-store</code> is the secure store.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$store-password</code> is the password for the secure store.
		                </p>
		            </item>
		        </ulist>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:convert-secure-store</code> function
		        </h3>
		        <p>This function converts a secure store from one format to another. It returns the converted store as xs:base64binary
				if successfully completed, empty sequence if not.</p>
		        <eg>
		            <spec:function>crypto:convert-secure-store</spec:function>($input-store as 
		            <spec:type>xs:base64binary</spec:type>,
				$input-format as 
		            <spec:type>xs:string</spec:type>,
				$output-format as 
		            <spec:type>xs:string</spec:type>) as 
		            <spec:type>xs:base64binary</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$input-store</code> is the secure store to be converted.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$input-format</code> is the format of the input secure store.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$output-format</code> is the format of the output secure store.
		                </p>
		            </item>
		        </ulist>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:get-secure-store-metadata</code> function
		        </h3>
		        <p>This function gets metadata for a secure store. It returns a crypto:metadata element.</p>
		        <eg>
		            <spec:function>crypto:get-secure-store-metadata</spec:function>($secure-store-handle as 
		            <spec:type>xs:long</spec:type>) 
					as 
		            <spec:type>element(crypto:metadata)</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$secure-store-handle</code> is the secure store handle.
		                </p>
		            </item>
		        </ulist>
		        <section>
		            <h4>The 
		                <code>crypto:metadata</code> element
		            </h4>
		            <p>The 
		                <code>crypto:metadata</code> element contains metadata about a resource.
		            </p>
		            <eg>
				&lt;crypto:metadata&gt;
				&lt;crypto:secure-store-type&gt;xs:string&lt;/crypto:secure-store-type&gt;
				&lt;crypto:provider&gt;xs:string&lt;/crypto:provider&gt;
				&lt;crypto:aliases-list&gt;xs:string&lt;/crypto:aliases-list&gt;
				&lt;crypto:size&gt;xs:integer&lt;/crypto:size&gt;
				&lt;/crypto:metadata&gt;
				</eg>
		            <ulist>
		                <item>
		                    <p>
		                        <code>secure-store-type</code> is the type of the secure store.
				
		                    </p>
		                </item>
		                <item>
		                    <p>
		                        <code>provider</code> is the provider that generated the secure store.
		                    </p>
		                </item>
		                <item>
		                    <p>
		                        <code>aliases-list</code> is the list of all the aliases in the secure store.
				
		                    </p>
		                </item>
		                <item>
		                    <p>
		                        <code>size</code> is the number of entries in the secure store.
				
		                    </p>
		                </item>
		            </ulist>
		        </section>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:add-entry</code> function
		        </h3>
		        <p>This function adds an entry to a secure store. It returns true if successfully completed, false if not.</p>
		        <eg>
		            <spec:function>crypto:add-entry</spec:function>($secure-store-handle as 
		            <spec:type>xs:long</spec:type>,
				$data as 
		            <spec:type>xs:base64binary</spec:type>,
				$alias as 
		            <spec:type>xs:string</spec:type>,
				$entry-password as 
		            <spec:type>xs:string?</spec:type>) as 
		            <spec:type>xs:boolean</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$secure-store-handle</code> is the secure store handle.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$data</code> is the data to be stored.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$alias</code> is the alias for the data to be stored.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$entry-password</code> is the password for the entry.
		                </p>
		            </item>
		        </ulist>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:get-entry</code> function
		        </h3>
		        <p>This function gets an entry from a secure store. It returns the entry.</p>
		        <eg>
		            <spec:function>crypto:get-entry</spec:function>($secure-store-handle as 
		            <spec:type>xs:long</spec:type>,
				$alias as 
		            <spec:type>xs:string</spec:type>,
				$entry-password as 
		            <spec:type>xs:string?</spec:type>) as 
		            <spec:type>xs:base64binary</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$secure-store-handle</code> is the secure store handle.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$alias</code> is the alias for the data to be stored.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$entry-password</code> is the password for the entry.
		                </p>
		            </item>
		        </ulist>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:delete-entry</code> function
		        </h3>
		        <p>This function delets an entry from a secure store. It returns true if successfully completed, false if not.</p>
		        <eg>
		            <spec:function>crypto:delete-entry</spec:function>($secure-store-handle as 
		            <spec:type>xs:long</spec:type>,
				$alias as 
		            <spec:type>xs:string</spec:type>,
				$entry-password as 
		            <spec:type>xs:string?</spec:type>) as 
		            <spec:type>xs:boolean</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$secure-store-handle</code> is the secure store handle.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$alias</code> is the alias for the data to be stored.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$entry-password</code> is the password for the entry.
		                </p>
		            </item>
		        </ulist>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:get-entry-metadata</code> function
		        </h3>
		        <p>This function gets metadata for a secure store entry. It returns a crypto:metadata element if entry exists, empty 
					sequence if
				the entry does not exist.</p>
		        <eg>
		            <spec:function>crypto:get-entry-metadata</spec:function>($secure-store-handle as 
		            <spec:type>xs:long</spec:type>,
				$alias as 
		            <spec:type>xs:string</spec:type>) as 
		            <spec:type>element(crypto:metadata)?</spec:type>
		        </eg>
		        <ulist>
		            <item>
		                <p>
		                    <code>$secure-store-handle</code> is the secure store handle.
		                </p>
		            </item>
		            <item>
		                <p>
		                    <code>$alias</code> is the alias for the data to be stored.
		                </p>
		            </item>
		        </ulist>
		        <section>
		            <h4>The 
		                <code>crypto:metadata</code> element
		            </h4>
		            <p>The 
		                <code>crypto:metadata</code> element contains metadata about a resource.
		            </p>
		            <eg>
				&lt;crypto:metadata&gt;
				&lt;crypto:creation-date&gt;xs:dateTime&lt;/crypto:creation-date&gt;
				&lt;crypto:type&gt;("certificate" | "key" | "other")&lt;/crypto:provider&gt;
				&lt;/crypto:metadata&gt;
				</eg>
		            <ulist>
		                <item>
		                    <p>
		                        <code>creation-date</code> is the entry's creation date.
				
		                    </p>
		                </item>
		                <item>
		                    <p>
		                        <code>type</code> is the entry's type.
		                    </p>
		                </item>
		            </ulist>
		        </section>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:list-trusted-certificate-authorities</code> function
		        </h3>
		        <p>This function lists the most-trusted certificate authorities in a secure store.</p>
		    </section>
		</section>
		
		<section>
		    <h2>Digital Certificates</h2>
		    <tr>
		        <td>
		            <code>digital-certificate</code>
		        </td>
		        <td>
		            <code>map(xs:string, xs:string)</code>
		        </td>
		        <td>The digital certificate to be used for signing the references. If this parameter is missing, an auto-generated 
					key pair will be used. The
				components of this parameter are given in the table 
		            <bibref ref="digital-certificate-parameter-components" /> below.(Optional)
		        </td>
		    </tr>
		    <table id="digital-certificate-parameter-components" border="1" frame="border">
		        <caption>Components of the 
		            <code>digital-certificate</code> parameter
		        </caption>
		        <thead>
		            <tr>
		                <th>Key (as 
		                    <code>xs:string</code>)
		                </th>
		                <th>Value</th>
		                <th>Meaning</th>
		            </tr>
		        </thead>
		        <tbody>
		            <tr>
		                <td>
		                    <code>keystore-type</code>
		                </td>
		                <td>
		                    <code>xs:string</code>
		                </td>
		                <td>The keystore type. If the type is not supported, this is an error 
		                    <bibref ref="error.keystoreType" />.
		                </td>
		            </tr>
		            <tr>
		                <td>
		                    <code>keystore-password</code>
		                </td>
		                <td>
		                    <code>xs:string</code>
		                </td>
		                <td>The keystore's password. If the keystore cannot be loaded or the password is incorrect, this is an error 
		                    <bibref 
					ref="error.readKeystore" />.
		                </td>
		            </tr>
		            <tr>
		                <td>
		                    <code>key-alias</code>
		                </td>
		                <td>
		                    <code>xs:string</code>
		                </td>
		                <td>The alias for the key pair used for signing. If no key pair exists for this alias, this is an error 
		                    <bibref ref="error.aliasKey"/>.
		                </td>
		            </tr>
		            <tr>
		                <td>
		                    <code>private-key-password</code>
		                </td>
		                <td>
		                    <code>xs:string</code>
		                </td>
		                <td>The password for the selected key.</td>
		            </tr>
		            <tr>
		                <td>
		                    <code>keystore-url</code>
		                </td>
		                <td>
		                    <code>xs:string</code>
		                </td>
		                <td>The URL of the keystore. If the URL is not correct, this is an error 
		                    <bibref ref="error.keystoreUrl"/>. If the 
					user has no acces to the keystore,
				this is an error 
		                    <bibref ref="error.deniedKeystore" />.
		                </td>
		            </tr>
		        </tbody>
		    </table>
				"digital-certificate" :=
				map {
				"keystore-type" := "JKS",
				"keystore-password" := "password",
				"key-alias" := "alias",
				"private-key-password" := "password",
				"keystore-url" := "/db/mykeystore"
				}
				
		    <p>TBD.</p>
		    <section>
		        <h3>The 
		            <code>crypto:generate-certificate</code> function
		        </h3>
		        <p>This function generates a digital certificate.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:generate-self-signed-certificate</code> function
		        </h3>
		        <p>This function generates, for development purposes, a self signed digital certificate.
				TODO: To be developed, if such function is of any use.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:validate-certificate</code> function
		        </h3>
		        <p>This function validates a digital certificate.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:parse-certificate</code> function
		        </h3>
		        <p>This function parses a digital certificate.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:generate-certification-path</code> function
		        </h3>
		        <p>This function validates the certification path for a digital certificate.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:validate-certification-path</code> function
		        </h3>
		        <p>This function validates the certification path for a digital certificate.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:generate-certification-request</code> function
		        </h3>
		        <p>This function generates a certificate signing request, in order to apply for a digital
				identity certificate, which is to be issued by a Certificate Authority .</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:validate-certification-request</code> function
		        </h3>
		        <p>This function validates a certificate signing request.</p>
		    </section>
		    <section>
		        <h3>The 
		            <code>crypto:validate-certificate-revocation-list</code> function
		        </h3>
		        <p>This function validates a certificate revocation list.</p>
		    </section>
		</section>
		
		<section>
		    <h2>Random Sequences Generation</h2>
		    <p>TBD.</p>
		    <section>
		        <h3>The 
		            <code>crypto:generate-random-number</code> function
		        </h3>
		        <p>This function generates a random number that is cryptographically strong.</p>
		    </section>
		</section>
		
		<section>
		    <h2>Cryptographic Hardware</h2>
		    <p>TBD.</p>
		</section>		
		
		<section>
		    <h2>The 
		        <code>crypto:options</code> element
		    </h2>
		    <p>The 
		        <code>crypto:options</code> element represents the options needed for the functions included in this module.
				Users will specify for a certain functions only the options mentioned in function's description above. In case a needed 
					option
				is not mentioned for a function, its default value will be used.
		    </p>
		    <eg>
				&lt;crypto:options&gt;
				&lt;crypto:option name = xs:string value? = xs:string&gt;
				any*
				&lt;/crypto:option&gt; *
				&lt;/crypto:options&gt; ?
				</eg>
		    <section id="provider-option">
		        <h3>The 
		            <code>provider</code> option
		        </h3>
		        <p>Represents the provider for the current operation. If the provider does not exist, this is an error 
		            <bibref ref="error.noProvider"/>.
		        </p>
		        <eg>
				&lt;crypto:option name = "provider"
				value = xs:string/&gt;
				</eg>
		    </section>
		    <section id="canonicalization-algorithm">
		        <h3>The 
		            <code>canonicalization-algorithm</code> option
		        </h3>
		        <p>This option represents the canonicalization algorithm applied to the 
		            <code>SignedInfo</code> element prior to performing
				signature calculations. The default value is "inclusive-with-comments". If the parameter specifies an unsupported 
					algorithm,
				this is an error 
		            <bibref ref="error.unknownAlgorithm"/>.
		        </p>
		        <eg>
				&lt;crypto:option name = "canonicalization-algorithm"
				value = "exclusive" | "exclusive-with-comments" | "inclusive" | "inclusive-with-comments" /&gt; ?
				</eg>
		    </section>
		    <section id="digest-algorithm">
		        <h3>The 
		            <code>digest-algorithm</code> option
		        </h3>
		        <p>This option represents the digest algorithm to be applied to the signed object. If the parameter specifies an unsupported
				algorithm, this is an error 
		            <bibref ref="error.unknownAlgorithm"/>.
		        </p>
		        <eg>
				&lt;crypto:option name = "digest-algorithm" value = xs:string /&gt;
				</eg>
		    </section>
		    <section id="signature-algorithm">
		        <h3>The 
		            <code>signature-algorithm</code> option
		        </h3>
		        <p>This option represents the algorithm used for signature generation and validation. If the parameter specifies an
				unsupported algorithm, this is an error 
		            <bibref ref="error.unknownAlgorithm"/>.
		        </p>
		        <eg>
				&lt;crypto:option name = "signature-algorithm" value = xs:string /&gt;
				</eg>
		    </section>
		    <section id="signature-namespace-prefix">
		        <h3>The 
		            <code>signature-namespace-prefix</code> option
		        </h3>
		        <p>This option represents the namespace prefix for signature.</p>
		        <eg>
				&lt;crypto:option name = "signature-namespace-prefix" value = xs:string /&gt;
				</eg>
		    </section>
		</section>
		
		<section class="appendix">
			<h2>Scenarios of usage</h2>
			<section>
				<h3>Generation of OAuth signature</h3>
				<pre class="xquery">
let $signature-base-string := "GET&amp;http%3A%2F%2Fexample.org%2Fresource%26oauth_consumer_key%3Dabcd%26
oauth_nonce%3DXxFM1VSdB6N%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1449422427%26
oauth_token%3Dijkl%26oauth_version%3D1.0"
let $key := "dpf43f3p2l4k3l03"
let $signature := crypto:hmac($signature-base-string, $key, "HMAC-SHA-1")

return $signature
				</pre>
			</section>
			<section id="generation-of-aws-signature-version-4">
				<h3>Generation of AWS Signature Version 4 signature</h3>
				<pre class="xquery">
let $region := "us-east-1"
let $service := 'iam'
let $date-YYYYMMDD := '20120215'
let $s3-secret-key := 'wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY'
let $kSecret := concat("AWS4", $s3-secret-key)

let $dateKey := crypto:hmac($date-YYYYMMDD, $kSecret, "HMAC-SHA-256")
let $dateRegionKey := crypto:hmac($region, $dateKey, "HMAC-SHA-256")
let $dateRegionServiceKey := crypto:hmac($service, $dateRegionKey, "HMAC-SHA-256")
let $signingKey := crypto:hmac("aws4_request", $dateRegionServiceKey, "HMAC-SHA-256”)

return $signingKey
				</pre>
			</section>
			<section>
				<h3>Generation of enveloped digital XML signature of a document</h3>
				<pre class="xquery">
let $doc :=
   &lt;data&gt;
      &lt;a&gt;1&lt;/a&gt;
      &lt;b&gt;7&lt;/b&gt;
      &lt;c /&gt;
      &lt;c /&gt;
   &lt;/data&gt;
let $signature := crypto:generate-signature($doc,
   map {
      "canonicalization-algorithm" := "inclusive-with-comments",
      "digest-algorithm" := "SHA1",
      "signature-algorithm" := "RSA_SHA1",
      "signature-namespace-prefix" := "digsig",
      "signature-type" := "enveloped",
      "key" :=
         "-----BEGIN RSA PRIVATE KEY-----
         ...
         -----END RSA PRIVATE KEY-----"
      }
)

return $signature
				</pre>
			</section>
			<section>
				<h3>Generation of enveloped digital XML signature of a document</h3>
				<p></p>
				<eg>
					let $doc :=
					&lt;data&gt;
					&lt;a&gt;1&lt;/a&gt;
					&lt;b&gt;7&lt;/b&gt;
					&lt;c /&gt;
					&lt;c /&gt;
					&lt;/data&gt;
					let $signature := crypto:generate-signature($doc,
					map {
					"canonicalization-algorithm" := "inclusive-with-comments",
					"digest-algorithm" := "SHA1",
					"signature-algorithm" := "RSA_SHA1",
					"signature-namespace-prefix" := "digsig",
					"signature-type" := "enveloped",
					"key" :=
					"-----BEGIN RSA PRIVATE KEY-----
					MIIEowIBAAKCAQEAhPxBGln4YOcOGOxmRYEN8nzYHYvQx+PP8GnbJ+kW4f6HvH8WMAUa2lTB6gib
					LzJGezhqkMy8NT8ogVz8xbra3AyK/IBDzXpWtPhSxVOCo6hJfTjj7wX3E2AVN9CTUOYrS/3iSu1q
					/6MoB6MDIj8wV0HO1ujXqEip45UgVl+xRVtU+1wiJQ7Gc8GEEyHVtK/X4joiyCEebJhFsI42Z9e4
					aETI/XOaLszyEQeipMRlyznpRL2x0chz+yj7KuwiMqBZmPYyeWBsbldW8xREwnHEyko5GWc6wkEi
					vgFwzKaZWo2ct3pmZ9vwXKecAxbeJbyJQl/PDfSnqcwyhL6pOaSAuQIDAQABAoIBAHo5hnR7wIb/
					lbteetjitjjqeY8eU/OD9DfYcu6Jkth/Ia4jd/cGmhmU0O0Sn96O7KyPu5H+OfUOaWIMXt400LZy
					aMON98NA77RAj4KBMI7OO0z2Hrgu2Vlbc+TqtJskESM04ulOsIroIAB02Ip/XSS1fS+UrbEjp9Fd
					3GzGYp2E6IF/YtTXMiqgdrZVAoDPtxiMR/1KXuETiBkeMxPvXfgePXLi/rYBDcecmfsCEzDX8RZV
					xLoPKFxuLaIrzdVhGVHwp88fB57OufLytmuvro71FNrFzcIO88NyDpEQVnsBadm9Ir0mb5uhYq9j
					YV444b2Gra0/onJm7e/zRUSSJGkCgYEA67Q8gBSADrkc0UCypjnFV8WWCQJBPspb9Vnf2MJi5aYM
					U5Sa/2H+tNoY+fJoa/eDSu1jeAn71TDcXZizihj3IT8gVdoXSncbcTulxEnaOi85Q2uKfSia16rX
					d+MufjJ4UDC7vR/Ve+zIQOxpzBmcFO5cMnLS3mJdpWSdS7DyQpMCgYEAkG+6udsQ02GEKaJZl2mi
					XBqe4Rh187sDCwiqSO5ItS4jUg1xF1cn1PuF2nvjztZyEsaKKYdiqekEQv3jA6gRsWFvRi/abFN3
					zau/5M42v7H1cgU7m+FsDywhN5IRAmGfEyL/2wpKuZ6lD2qqhGkXmxqyEqgmEClyIwxJKHWiAwMC
					gYBCJK8Bpj8VYp8SnZxEh1u4uMrUtlxG2ZSasmDdvBbyqPk2jzI7zm0ipT1zDrJ88dVXNmy+Z9bS
					ycZdQZfIfh8DpmpVjUER9YCu8vUeszbZMx1XrRsM6lMhiGC01PzcDx+yKSrV9NP81cKQbYd27gzd
					1tHqmkxQebwbyLNXZU1mnwKBgDpuiPsBbdgmHkJ9pIMFwCJEvrvPmoBEyuFe2wzwIUfy52UdfP/1
					SW73ZlpSPoIB7Vo9Kc3NMJQOaaP0dC+Zgbbh9RNO7q1eQxxYfCRDbJC2nNZI2amhU4b70mBZ3jm5
					ZpJmWV2y1zIqxRnsjBlPLraX4Sx9DBEDw2H8aWhN1oIjAoGBANc0gizRHGfOK2UASXskuO5Ueias
					6z0V7J/m93E7wK8IQHcZXGloy8S9QSX6uAqe48ZDVCZGPxqq7TppT+P9WsdqkXqxR7M/KLa+7Y6C
					s1tkDtD9uOJN6CsLuVjfuo4ZT5SwC7pq842aQrqJveKWKdzEorQjWKeN8OM2wzEMs0P1
					-----END RSA PRIVATE KEY-----"
					}
					)

					return $signature
				</eg>
			</section>			
		</section>

		<section class="appendix">
			<h2>Error Codes</h2>
			<dl>
				<dt>
					<dfn id="dfn-errCRYPTO001">err:CRYPTO001</dfn>
				</dt>
				<dd>A cryptografic error occurred.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO002">err:CRYPTO002</dfn>
				</dt>
				<dd>The specified algorithm is not supported.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO003">err:CRYPTO003</dfn>
				</dt>
				<dd>The specified signature type is not supported.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO004">err:CRYPTO004</dfn>
				</dt>
				<dd>I/O error while reading keystore, or the password is incorrect.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO005">err:CRYPTO005</dfn>
				</dt>
				<dd>Permission denied to read keystore.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO006">err:CRYPTO006</dfn>
				</dt>
				<dd>The keystore URL is invalid.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO007">err:CRYPTO007</dfn>
				</dt>
				<dd>The keystore type is not supported.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO008">err:CRYPTO008</dfn>
				</dt>
				<dd>Cannot find key for alias in given keystore.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO009">err:CRYPTO009</dfn>
				</dt>
				<dd>Cannot find Signature element.</dd>
				<dt>
					<dfn id="dfn-errCRYPTOn010">err:CRYPTO010</dfn>
				</dt>
				<dd>No such padding.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO011">err:CRYPTO011</dfn>
				</dt>
				<dd>Incorrect padding.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO012">err:CRYPTO012</dfn>
				</dt>
				<dd>The encryption type is not supported.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO013">err:CRYPTO013</dfn>
				</dt>
				<dd>The cryptographic key is invalid.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO014">err:CRYPT014</dfn>
				</dt>
				<dd>Illegal block size.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO015">err:CRYPTO015</dfn>
				</dt>
				<dd>The decryption type is not supported.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO016">err:CRYPTO016</dfn>
				</dt>
				<dd>The provider is not set.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO017">err:CRYPTO017</dfn>
				</dt>
				<dd>The 'enveloped' and 'enveloping' signatures have to be applied to only one resource.</dd>
				<dt>
					<dfn id="dfn-errCRYPTO018">err:CRYPTO018</dfn>
				</dt>
				<dd>The initialization vector is not correct.</dd>
			</dl>
		</section>

	</body>
</html>
